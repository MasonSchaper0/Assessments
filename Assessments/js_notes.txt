Variables, Data Types, etc.

Primitive Values:

Boolean = true/false
String = ‘ ‘, “ “, ` ` (any sentences/word or letter)
integer = 1 (any number)


Block level scope:

const - variable that doesn’t change its value

let - variable that can change its value


Object (stores information about a specific element)

const person = {
name: ‘John’;
age: 20;
job: student;
}


Reference Values:

let newName = name;
newName = ‘John’;

let newPerson = person;
newPerson.name = ‘Josh’;


Concatenation:

Const name = “John”;
Const x = `Hello, I’m “ + name + “. Nice to meet you.`
Template literals: 

Const x = “Hello, I’m ${name}. Nice to meet you.”


Strings:

const x = “hi sir”;
console.log(x);

x = s.toUpperCase();

x = x.toLowerCase();

x = x.charAt(0);

x = x.indexOf(‘d’);

x = x.substring(0, 2); // will only print ‘hi’

x = x.slice(-4); // will only print ‘h’

x = x.trim();

x = x.replace(‘sir’, ‘John’); // replaces sir with John

x = x.includes(‘hello’); // returns false because this isn’t included in the string.

x = x.split(‘’); // will split each each character into an array


Math

Math.sqrt(9); // finds the square root of 9 (3)

Math.abs(-1); // turns into a positive integer

Math.round(3.3); // rounds to the nearest whole number (3)

Math.ceil(4.3);

Math.floor(2.3); // converts into a whole number

Math.pow(2, 3); // 2 to the power of 3 (8)

Math.random(); // generates a random number from 0 - 1

Math.floor(Math.random() * 10 + 1); // generates a random number from 1 - 10




Functions

A Javascript function is a block of code designed to perform a specific task. It’s also a way to group code together, making it easier to understand.

Basic function:

function functionName(parameter) {
	console.log(“function body”);
}

callFunction();


Arrow functions

An arrow function in JavaScript is a more concise way to write function expressions. 
Introduced in ES6, arrow functions are especially useful for shorter functions and 
are often used with array methods like map, filter, and reduce.

Syntax:

(param1, param2, ...) => expression
Parentheses: Required if there are zero or multiple parameters, but optional if there's exactly one parameter.
Arrow (=>): Separates the parameter list from the function body.
Expression: If the body has a single expression, it implicitly returns the result. For multiple statements, you must use curly braces {} and an explicit return.

Examples:
1. Basic Arrow Function:
Equivalent to function expression:

// Traditional function
const add = function (a, b) {
  return a + b;
};

// Arrow function
const addArrow = (a, b) => a + b;

console.log(add(2, 3));        // Output: 5
console.log(addArrow(2, 3));   // Output: 5

2. Single Parameter (Parentheses Optional):
If the function takes a single parameter, you can omit the parentheses:

const square = x => x * x;

console.log(square(4)); // Output: 16

3. No Parameters (Parentheses Required):
If there are no parameters, use empty parentheses:

const greet = () => 'Hello, World!';

console.log(greet()); // Output: Hello, World!

4. Multiline Function Body:
For functions with multiple statements, use curly braces {} and return:

const multiply = (a, b) => {
  const result = a * b;
  return result;
};

console.log(multiply(3, 4)); // Output: 12

Key Characteristics:
1. Implicit Return:
If the function body contains a single expression, the result is returned implicitly without using the return keyword.

const double = x => x * 2;
console.log(double(5)); // Output: 10

2. Lexical this Binding:
Arrow functions do not have their own this. Instead, they inherit this from the surrounding scope. This makes them useful in situations where this can be ambiguous.

function Person(name) {
  this.name = name;
}

Person.prototype.sayName = function () {
  setTimeout(() => {
    console.log(`My name is ${this.name}`); // Arrow function inherits `this` from `sayName`
  }, 1000);
};

const john = new Person('John');
john.sayName(); // Output: My name is John
Note: In contrast, a traditional function would require bind(this) or saving this to a variable.

3. Cannot Be Used as Constructors:
Arrow functions cannot be used with new to create objects because they don’t have a this binding or a prototype.

const Foo = () => {};
const obj = new Foo(); // TypeError: Foo is not a constructor
When to Use Arrow Functions:
When you need concise and clean syntax.
When this binding needs to refer to the surrounding lexical scope.
For callbacks or methods like map, filter, reduce, etc.
When Not to Use Arrow Functions:
When defining methods in an object literal or class (use traditional function to preserve this binding).
When creating constructor functions.


Object Literals

In JavaScript, an object literal is a simple way to create an object using curly braces {}. 
It allows you to define properties (key-value pairs) and methods directly.

Syntax:

const objectName = {
  key1: value1,
  key2: value2,
  key3: function() {
    // Method logic
  }
};

Keys are the property names (can be strings, or symbols).
Values can be of any data type: strings, numbers, arrays, functions, or even other objects.

Example:

const person = {
  firstName: 'John',
  lastName: 'Doe',
  age: 30,
  hobbies: ['reading', 'gaming', 'coding'],
  greet: function () {
    return `Hello, my name is ${this.firstName} ${this.lastName}.`;
  },
  isAdult: function () {
    return this.age >= 18;
  }
};

console.log(person.firstName); // Output: John
console.log(person.greet());   // Output: Hello, my name is John Doe.
console.log(person.isAdult()); // Output: true

Features:
1. Shorthand Property Names:
If the property name and the variable name are the same, you can use shorthand:

const firstName = 'Alice';
const lastName = 'Smith';

const user = { firstName, lastName };
console.log(user); // Output: { firstName: 'Alice', lastName: 'Smith' }

2. Computed Property Names:
You can use an expression inside square brackets [] to compute the property name dynamically:

const key = 'dynamicKey';
const obj = {
  [key]: 'This is a dynamic value',
};

console.log(obj.dynamicKey); // Output: This is a dynamic value

3. Method Definition Shorthand:
You can define methods without the function keyword:

const calculator = {
  add(a, b) {
    return a + b;
  },
  subtract(a, b) {
    return a - b;
  }
};

console.log(calculator.add(2, 3));      // Output: 5
console.log(calculator.subtract(5, 3)); // Output: 2

4. Nested Objects:
Objects can have other objects as values:

const car = {
  brand: 'Tesla',
  model: 'Model 3',
  specifications: {
    range: '358 miles',
    topSpeed: '140 mph',
  }
};

console.log(car.specifications.range); // Output: 358 miles

Advantages of Object Literals:
Simple and concise: No need for a constructor or class to create objects.
Flexible: You can easily add, modify, or delete properties.
Modifying Object Properties:

const book = {
  title: 'JavaScript Basics',
  author: 'Jane Doe',
};

// Add a new property
book.year = 2021;

// Modify an existing property
book.author = 'John Doe';

// Delete a property
delete book.year;

console.log(book);
// Output: { title: 'JavaScript Basics', author: 'John Doe' }


Date Constructor
The Date() constructor creates Date objects. When called as a function, it returns a string representing the current time.
Const date = new Date(); // Will return the current date and time
Const bday = new Date(06-27-2006); // Will return the following date but with no specified time.
Date Object Methods:
X = x.getTime(); // 
x = x.getFullYear(); // gets the full year, example: ‘1932’
x = x.getMonth();
x = x.getDate();
x = x.getDay();
x = x.getHours();
x = x.getMinutes();
x = x.getSeconds();
x = `${x.getFullYear()}-${x.getMonth() + 1} -${x.getDate()}`;

x = Intl.DateTimeFormat(‘en-US’).format(x); // displays the date in the united states date format
x = x.toLocaleString(‘default’, {month: ‘short}); // display the month in short form (october would be ‘oct’).




Arrays 


An array is a variable that can hold more than one value. Arrays go by index, meaning it starts counting from 0.


Example: const alphabet = [‘a’, ‘b’, ‘c’];


Access a specific item by index:


let x;
x = alphabet[0]; // index 0 is ‘a’


x = alphabet.length; // the length would be 2 because the last item is in index 2.


x = `my favorite letter is ${alphabet[2]}`; // ‘my favorite letter is b’


Array Methods


Const arr = [34, 55, 95, 20, 15];


arr.push(100); // adds a new element at the end of an array


arr.pop(); //removes last element of an array


arr.unshift(99); // adds new element at the beginning of an array


arr.shift(); // removes the first element of an array


arr.reverse(); // reverses the whole array


x = arr.indexOf(15); // will log index 4


x = arr.slice(1); // removes an element from an array


X = arr.splice(2, 2); // will add ‘2’ after index 2




JSON


JSON stands for JavaScript Object Notation and is a text format for storing and transporting data.
In JSON, keys must be strings, written with double quotes:
{
name: “Jason”;
}


JSON.stringify(); // turns object into a JSON string
JSON.parse(); // turns strings into objects




























Classes

class name {
	constructor(parameters) {
		this._parameters = parameters;
	}

	get parameters() {
		return this._parameters;
	} //getter

	set parameters(newParameters) {
		This._parameters = this._newParameters;
	} //setter


	toggleStatus() {
		// add functions here
	} // method
} 

Class name2 extends name { //connects the parent class
constructor(parameters) {
		super(parameter); // call super to plug in the parameters from the parent class
	}
}

Modules

Message Mixer:

Caesar Cipher - in which the characters of the input message are shifted alphabetically by a given amount.

Symbol Cipher - in which select characters from the input message are replaced with visually similar symbols.

Reverse Cypher - in which each word of the input message is reversed in place.

.require() // used to import files

Example: const encryptors = require(“./encryptors.js”);;

Import and export: export a function on a file and import it into another.

Named exports/imports have more than one parameter using “{}”.

Example:

export {getValue, getOtherValue);

import {getValue, GetOtherValue} from ‘path/to/main.js’;

Unnamed export/imports only have one parameter.

Example:

export getValue;

import getValue from ‘./main.js’;

Promises

A promise can be in 1 of 3 states:

Pending: the initial state.
Fulfilled: the operation was a success and has resolved a value.
Rejected: The operation was a fail.

.then() will return a promise with the same settled value as the promise it was called on if no appropriate handler was provided.

example:

prom
.then((resolvedValue) => {
   console.log(resolvedValue);
})
.then(null, (rejectionReason) => {
   console.log(rejectionReason);

// in the example above, we have a function that rejects the request and accepts it.

.catch() : instances schedules a function to be called when the promise is rejected

const promise1 = new Promise((resolve, reject) => {
  throw new Error('Uh-oh!');
});

promise1.catch((error) => {
  console.error(error);
});
// Expected output: Error: Uh-oh!


Chaining Multiple Promises: depend on each other to execute or that must be executed in a certain order, also known as composition.


firstPromiseFunction()
.then((firstResolveVal) => {
  return secondPromiseFunction(firstResolveVal);
})
.then((secondResolveVal) => {
  console.log(secondResolveVal);

// example above, firstPromiseFunction returns a promise then invoking .then() with an anonymous function. Then the successhandler (secondResolveVal) returns the new value of firstResolveVal.

Promise all() : only used when every argument in a promise resolves and if any promises in the argument array rejects, the single promise returned with Promise all() will be rejected as well.



Async


Async keyword: Each time when an async function is called, it returns a new Promise which will be resolved with the value returned by the async function, or rejected with an exception uncaught within the async function


async function {
// func body	
}
My func();

Await keyword: The await keyword can only be used inside an async function. await is an operator: it returns the resolved value of a promise.


function resolveAfter2Seconds() {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve('resolved');
    }, 2000); // resolves after 2 seconds
  });
}

async function asyncCall() {
  console.log('calling');
  const result = await resolveAfter2Seconds();
  console.log(result);
  // Expected output: "resolved"
}

asyncCall();

await is not a variable it is a keyword. ALSO -> Top-Level await (ES2022+): “If you attempt to use await at the top level in environments not supporting ES2022+ or in non-modules, you’ll get a syntax error.”
Example ->
async function fetchData() {
  const response = await fetch('https://api.example.com/data');
  const data = await response.json();
  console.log(data);
}
fetchData();




Independent Promises : async function contains multiple promises which are not dependent on the results of one another to execute


Here are the steps:

Make an async function
Declare your variables
Log the variables in a phrase using ${ await variable}
Invoke your function

Example:

let {cookBeans, steamBroccoli, cookRice, bakeChicken} = require('./library.js');

async function serveDinner() {
 const vegetablePromise = steamBroccoli();
 const starchPromise = cookRice();
 const proteinPromise = bakeChicken();
 const sidePromise = cookBeans();
 console.log(`Dinner is served. We're having ${await vegetablePromise}, ${await starchPromise}, ${await proteinPromise}, and ${await sidePromise}.`);
}

serveDinner();


HTTP Requests 

GET requests

The fetch() function : Creates a request object that contains relevant information that an API needs. Sends that request object to the API endpoint provided. Returns a promise that ultimately resolves to a response object, which contains the status of the promise with information the API sent back.


Boilerplate for fetch() : 

fetch(endpoint, {cache: 'no-cache'}).then(response => {
	// body
 })

// the cache: ‘no-cache’ is used to support a specific browser

The throw method (goes inside a fetch function) : The throw statement throws a user-defined exception. Execution of the current function will stop (the statements after throw won't be executed), and control will be passed to the first catch block in the call stack. If no catch block exists among caller functions, the program will terminate.

Throw new Error (‘Request Failed!’); // this will stop the current function and revert back to the first block.

.then() method : used with promises to handle asynchronous operations. It accepts two callback functions: one for handling a promise’s resolved value and one for handling its rejection. It returns a new promise, allowing for method chaining.

Example:

.then (parameter => { //callback function
	//body
}).then (paramater2 => { // callback function
	
})

POST requests 

fetch("https://jsonplaceholder.typicode.com/todos", { // add keys to the fetch function
  method: "POST",
  body: JSON.stringify({
    userId: 1,
    title: "Fix my bugs",
    completed: false
  }),
  headers: {
    "Content-type": "application/json; charset=UTF-8"
  }
});

// the body holds the data to be sent to the server and added to the JSONPlaceholder todos API. Also, the headers hold the type of content you want to send to the server, which in this case is JSON data.



// you’re able to attach multiple .then() methods to each other by adding another one at the end of the method. You can also add call-back functions inside the .then() methods.

Async GET requests

Example:
const getSuggestions = async () => { 
 const wordQuery = inputField.value;
 const endpoint = `${url}${queryParams}${wordQuery}`;
 try {
   const response = await fetch(endpoint, {cache: 'no-cache'})
   if (response.ok) {
     const jsonResponse = await response.json();
     renderResponse(jsonResponse);
   }
 }
 catch (error) {
   console.log(error);
 }
}

Async POST requests

async function postData(url = '', data = {}) {
 const response = await fetch(url, {
   method: 'POST',
   headers: {
     'Content-Type': 'application/json'
   },
   body: JSON.stringify(data)
 });
 return response.json(); // parses JSON response into native JavaScript objects
}










c



});


});

